# ****Spring 5 Integration: Getting Started****

# Course Overview

### General Overview

Spring Integration: Getting Started. I am an independent software developer with many years of experience designing and building enterprise software systems in Java with Spring. In almost all software projects you're going to have to make your software connect to other systems. Often this involves writing lots of plumbing code, which is code that's not about the real business logic of your application and that takes a lot of time to write and maintain. In this course, we're going to dive into Spring Integration, which has lots of ready‑made components for connecting to different systems without the need to write a lot of plumbing code. Some of the major topics that we'll cover include, Enterprise Integration Patterns, which are the design patterns that Spring Integration is based upon; using asynchronous messaging to connect components within your application, as well as different applications; point‑to‑point messaging and publish‑subscribe messaging; and ways to handle errors in your Spring Integration application. By the end of this course you will have a solid understanding of Spring Integration and Enterprise Integration Patterns and you'll be ready to use Spring Integration in your own work. Before beginning the course you should be familiar with the basics of the Spring Framework. From here you should feel comfortable diving deeper into Spring Integration with the other courses in the Spring Integration learning path. I hope you'll join me on this journey to learn Spring Integration with the Spring Integration: Getting Started course at Pluralsight.

# Introduction and Getting Set Up

### Overview

Welcome to the project, Spring Integration, which is all about using Enterprise Integration Patterns to connect components inside your Spring application and external systems using asynchronous messaging. Have you ever needed to create an application that needed to get files from an FTP server? If you have, you've probably done it by using an FTP client library, and you will have noticed that you needed to write code that dealt with details such as setting up a connection and logging in, navigating through the service file system, and downloading files using the API of the particular FTP client library that you're using. So you had to write what's called plumbing code, which is code that's not business logic, but that deals with the infrastructure behind the business logic. Writing plumbing code can be tedious and time consuming and distracts you from what your application is really about. Spring Integration helps you to avoid writing lots of plumbing code because it provides many components that you can use out of the box to connect to systems using many different protocols and APIs such as FTP servers, messaging brokers, web services, relational and NoSQL databases, email, web sockets, and many more. Even more importantly, it helps you to keep integration codes separate from the actual business logic. This will help you write clean, maintainable, and testable code. Spring Integration is based on the Enterprise Integration Patterns, a set of design patterns that is focused on connecting software components and systems using asynchronous messaging. Many of the concepts and much of the terminology used in Spring Integration comes from the Enterprise Integration Patterns, so we will take some time to look at these patterns. Spring Integration is very much relevant in modern software architectures based on microservices. It's used as the basis for other Spring Framework projects such as Spring Cloud Stream for building highly‑scalable event‑driven microservices. In this module, I'll first give you a quick overview of what we mean by integration and what asynchronous messaging is. Then we will cover the core concepts of Enterprise Integration Patterns and Spring Integration. We'll also go over some practical points, such as what I expect you to already know, what other courses you might want to follow, and what software you will need to work hands on with the examples in this course. I highly recommend that you not just watch the presentation, but that you also try out the examples on your own computer and experiment with Spring Integration yourself. It's like learning how to ride a bicycle. You don't learn it by reading a book or watching a presentation; you have to do it yourself. The code for all the examples is available for download on the course page at Pluralsight. To make it all come alive, we will build parts of a system to register attendees to the Globomantics Tech Conference throughout this course. The demo application will consist of multiple components that communicate with each other and with external systems by using messaging, making use of many of the features that Spring Integration provides. At the end of this course, you will have a solid understanding of Enterprise Integration Patterns and Spring Integration, and you'll be ready to use it in your own projects. I hope you're looking forward to learning Spring Integration. Let's get started.

### Setting the Scene

All right, to get started you first need some background information. We will set the scene by taking a closer look at what integration means in this context and by introducing you to the Enterprise Integration Patterns. The Enterprise Integration Patterns focus on asynchronous messaging, so we will also take a look at what exactly that is and why it's useful. Then I'll give you a first look at Spring Integration and I'll explain what Enterprise Integration Patterns have to do with it. Many companies have many different software systems and applications to run their business. These systems often have to be connected to work with each other and also to systems outside of the company itself. Connecting these different systems is what we mean by integration. Integrating systems is not always easy because the systems may have vastly different interfaces and use different data formats. Some of the ways in which systems can be connected together include web services, messaging systems, exchanging files via FTP, shared databases, email, and even custom application‑level networking protocols. Integration is about connecting systems using these mechanisms and also about translating data between different formats. As a software developer you have undoubtedly heard of design patterns. Design patterns are general, reusable solutions to common software design problems. In 2003, Gregor Hohpe and Bobby Woolf published a book with the title Enterprise Integration Patterns, which describes 65 design patterns that specifically have to do with integration problems. Although 2003 is long ago in the fast‑changing world of software development, most of the book is still very much relevant in today's world of microservices and cloud computing that didn't exist yet when the book was written. Since Spring Integration is based on the Enterprise Integration Patterns, we will look into the main concepts of Enterprise Integration Patterns in this course. If you want to know more about Enterprise Integration Patterns, then you can find detailed information about the book and the patterns on the books website www.enterpriseintegrationpatterns.com. You can of course also buy the book. The book focuses on using asynchronous messaging as a solution for integrating systems. Let's take a quick look at what that is and how it differs from other ways to connect systems. One very common way to let software components communicate with each other is through web services. Especially RESTful web services over HTTP, with JSON as the common data format, are frequently used. Web services work in a synchronous way. The client sends a request to the server and then waits until the server has processed it and sends back a response. However, communication does not always need to be synchronous. In many cases, it can be asynchronous instead. When using an asynchronous messaging system the sender sends a message and immediately continues processing, not waiting for a response. The messaging system will make sure that the message is delivered to the receiver at some point in the future. If a response is needed, a message might be sent back to the original sender in the same way. It's the same as the difference between talking to someone on the phone and sending someone a text message. Talking on the phone is synchronous, you say something and then wait for the other person to respond to what you said. Sending a text message is asynchronous, you send the message and continue doing other things. At some point in the future the other person will read your message. Asynchronous messaging has a number of advantages over synchronous request response processing. For example, the sender of a message doesn't have to wait until the receiver sends back a response, which makes systems more responsive. Messages can be buffered, for example in a queue. This makes it possible for the system to continue working if the receiver is temporarily unavailable. When the receiver is back up again, it continues to process messages that are waiting for it in the queue. This makes systems able to deal with temporary failures without losing data. A queue also helps to prevent the receiver being overwhelmed with requests because the receiver can get messages from the queue and process them at a rate that is independent of how fast the sender is putting messages onto the queue. Imagine an online shop, for example. When a customer places an order, the website needs to inform the warehouse that the ordered items need to be shipped to the customer. Suppose that the communication between the website and the warehouse would happen via a synchronous web service call. If there is a problem so that the warehouse is temporarily unavailable, then the customer wouldn't be able to place their order. That would be annoying. It would work better if the communication between the website and the warehouse would work via asynchronous messaging. The website sends a message to the warehouse using a messaging system and immediately informs the customer that their order has been placed. The messaging system might temporarily store the message in a queue and deliver it to the warehouse whenever the warehouse is available to process it. So, what exactly is Spring Integration and what does it have to do with Enterprise Integration Patterns and asynchronous messaging? Spring Integration is an implementation of the Enterprise Integration Patterns based on the Spring Framework, which enables you to use the Enterprise Integration Patterns in your own Spring‑based applications. Since it's part of the Spring Framework family of projects, the way you use it in your applications will be familiar if you know the Spring Framework. You will use Spring beans, dependency injection, Aspect‑Oriented Programming, and other features of the Spring Framework to make your application modular, maintainable, and testable. It will make it easy to connect your business logic components with each other and with external systems through asynchronous messaging without the need to write a lot of plumbing code. Before we dive into the details of working with Spring Integration, we will take a closer look at the main concepts and terminology of Enterprise Integration Patterns.

### Understanding Enterprise Integration Patterns

Since Spring Integration is based on the Enterprise Integration Patterns, you will have to understand the basic concepts of the Enterprise Integration Patterns in order to understand and use Spring Integration. Let's take a look at the most important concepts and patterns. The Enterprise Integration Patterns are all about asynchronous messaging, so the first thing to understand is what exactly a message is. A message is a unit of data that is transmitted from a sender to one or more receivers via a messaging system. In the view of Enterprise Integration Patterns, a message consists of two parts, the payload and headers. The payload is the actual content of the message. This can be any kind of data, and the meaning of the payload is application specific. The headers of the message contain metadata, which can be anything that the messaging system needs to deliver the message to the receiver, for example, a unique ID, timestamp, correlation ID, and return address. If you know how HTTP works, then this model of a message will look familiar. An HTTP request or response also consists of headers with metadata and, optionally, a body that contains application‑specific data. To get messages from a sender to a receiver, they are transported over a message channel. A message channel is the pipe, so to speak, that gets the message from the sender to the receiver. Note that the Enterprise Integration Patterns are abstract ideas and not prescriptions about specific implementations of these ideas and software. A message channel is the abstract idea of something that carries messages from a sender to a receiver. There are many different ways to implement message channels. Queues are an example, but a message channel is not always a queue. There are two main types of message channels, which are Point‑to‑Point Channels and Publish‑Subscribe Channels. A Point‑to‑Point Channel is a message channel that connects exactly one sender with exactly one receiver. One possible implementation of Point‑to‑Point Channels are queues. Remember the online shop example that I mentioned earlier. There, a Point‑to‑Point Channel in the form of a message queue was used to have the website send messages to the warehouse to process orders from customers. In the next module, we will get started working with Spring Integration by first using Point‑to‑Point message channels. The other main type of message channel is the Publish‑Subscribe Channel. A Publish‑Subscribe Channel is used to broadcast messages from one sender to multiple receivers. One common scenario where you would want to use a Publish‑Subscribe Channel is to broadcast event notifications to parts of your software that are interested in particular types of events. After we've looked at point‑to point‑messaging, we will look at how we can use publish/subscribe messaging in our demo application for this course. When you work with a messaging system, senders and receivers of messages need to connect to it in some way to be able to send and receive messages. A message endpoint is the part of the code of a sender and a receiver that connects to the messaging system. This is a very general idea, and there are more patterns that describe more specific types of message endpoints, such as channel adapters, gateways, and service activators. I realize that this might sound a bit vague if you're completely new to this, but don't worry, it will all become more clear once we start working with message endpoints during this course and we encounter different kinds of endpoints. The important thing to remember for now is that the term message endpoint refers to some piece of code that connects to the messaging system for sending or receiving messages. As we will see, Spring Integration provides you with many different message endpoints in the form of channel adapters and gateways to connect to many different types of systems from message brokers to databases, email servers, web services, and much more. Another main Enterprise Integration Patterns concept is message transformation. Different systems often produce and consume data in different formats. For example, a sender might produce messages in JSON format, while the receiver expects XML. You'll need a message translator between them to convert messages from JSON to XML. Other kinds of message transformers work on the headers rather than the payload of a message or enrich the content of a message with data coming from another source, such as a database. The Enterprise Integration Patterns book describes several specific types of message transformation patterns. The final concept I'll mention here is message routing. There might be situations where the receiver of a message that gets sent to a message channel is not always fixed. You might want to decide, for example, based on a specific header value in the message, which receivers should process the message. A message router is a component in a messaging system that makes such decisions. The messaging system might even decide to drop a message altogether and not deliver it to any receiver. A component that makes such decisions is a message filter. Just like message transformation is really a category of more specific patterns, there are also more specific message routing patterns. These are the basics of Enterprise Integration Patterns. I've introduced you to the main concepts and categories of patterns, messages, channels, endpoints, transformation, and routing. Of course, there's a lot more to Enterprise Integration Patterns. The book has more than 700 pages, far too much information to summarize in a few minutes. But you now know what it's about, and you'll learn more as we encounter new concepts during this course.

### Introducing Spring Integration

You now know what Enterprise Integration Patterns are, but what exactly is Spring Integration and how does it relate to Enterprise Integration Patterns? Spring Integration is an implementation of the Enterprise Integration Patterns, which enables you to write your own Spring‑based applications that use the patterns. It contains many ready‑to‑use implementations of the concepts of Enterprise Integration Patterns in the form of interfaces and classes that are designed with the main principles of the Spring Framework in mind. It has interfaces and classes for messages, different kinds of message channels, many different kinds of endpoints, and transformers and routers. You can use these components using the standard Spring Framework programming techniques, such as dependency injection, which helps you to maintain separation of concerns between business logic and integration logic. If you are familiar with the Spring Framework, you know that you can configure Spring beans in the application context using XML or with annotations in Java code. Spring Integration adds XML namespaces and annotations specifically for configuring Spring Integration components. Besides the usual XML and annotations to configure your application context, Spring Integration also provides a domain‑specific language to configure components. Using this domain‑specific language, you can configure Spring Integration components in a readable way in Java code The idea is that you configure messaging channels, endpoints, transformers, and routers in a declarative way. Coming back to the example of connecting to an FTP server that I mentioned in the beginning of the course, instead of writing a lot of plumbing code that deals with the details, you configure an FTP inbound channel adapter that downloads files on a regular schedule and puts a message on a channel whenever a new file is downloaded. Then you configure a service activator that calls your business logic when it receives a message on the channel. You can find the reference and API documentation for Spring Integration at spring.io/projects/spring‑integration.

### Prerequisites and Learning Path

Let's take a few minutes to understand what you should already know to get the most out of this course and what other courses you might want to follow before and after this course. This course is meant for Java developers who are already familiar with the Spring Framework. If you haven't used the Spring Framework before or if you're brand new to programming in Java, then I recommend that you follow other Java and Spring Framework fundamentals courses first. You should be familiar with the core concepts of the Spring Framework, such as Inversion of Control and dependency injection, Spring beans and configuring them using XML and annotations. Some other Spring projects that we will use besides Spring Integration are Spring Web MVC, Spring Data JPA, and Spring Boot. It will help if you have at least basic knowledge about these Spring projects. There are many excellent courses about Java and Spring available on Pluralsight. Just search for them in the Pluralsight app or on the website and you'll find them. This course is meant to be your first course about Spring Integration and Enterprise Integration Patterns. It will be the first in a series of courses organized in a Spring Integration learning path. At the moment I'm creating this course, other authors and I are busy creating this learning path so more courses that will go deeper into specific Spring Integration topics will be available soon on Pluralsight or they already are, depending on when you are viewing this. These will be great to follow after this getting started course.

### Setting up Your System

Let's take a minute for some practical things so that you are prepared to follow along with the examples in this course. You will need to have a few pieces of software on your computer to be able to follow along. First of all, obviously, you'll need a JDK. You probably already have it on your system, but in case you haven't, you can download it from Oracle's website. There are also a number of other parties that offer builds of OpenJDK, for example, adoptopenjdk. I will be using JDK 11 since Java 11 is the current long‑term support Java release. All the example projects in this course are Maven projects, so we will need Apache Maven to build them. You can get Apache Maven at maven.apache.org. I will use IntelliJ IDEA for the demos, but you are free to choose whatever IDE you want to use. For some of the examples, we will use a message broker. I chose to use RabbitMQ because it's open source, available for free, and because it's popular and supported by Spring. You can install RabbitMQ directly on your system, but I'm going to use Docker to run RabbitMQ. It's not absolutely required to do this with Docker, but I'll use that because it makes it super easy to install, start, and stop RabbitMQ in a container sandbox without having to install it separately on my system.

### Summary

This is just the first module and you've already learned quite a lot. Spring Integration is an implementation of the Enterprise Integration Patterns, which is a set of 65 design patterns that are described in the book Enterprise Integration Patterns by Gregor Hohpe and Bobby Woolf. The patterns focus on integrating software components and systems using asynchronous messaging. Asynchronous messaging has a number of advantages over synchronous communication techniques that help make systems more responsive and able to deal with failures. You've learned the core concepts of Enterprise Integration Patterns. A message consists of a payload and headers and is transported from the sender to the receiver through a message channel. There are two main types of channels, which are point‑to‑point and publish‑subscribe channels. Message endpoints are the way to connect to message channels. There are many different types of message endpoints. You will learn about channel adapters, gateways, service activators, and other types of endpoints as we go along. Two other main categories of Enterprise Integration Patterns are message transformation and message routing. Spring Integration gives you many ready‑to‑use message endpoint implementations that you can use to connect to different types of systems, using different interfaces and protocols. By using these endpoints you don't have to write a lot of plumbing code. After all this theory, it's time we start working with Spring Integration hands on. In the next module, we'll start building our demo application by first learning how to implement point‑to‑point messaging. Let's go!

# Getting Started with Point-to-Point Messaging

### Overview

Okay, now you know what Spring Integration is about, and it's time we start working with it in practice. In this module, we're going to start working on the demo application. It's going to be a web application where people can register for the Globomantics Tech Conference. We're going to start with a plain and simple Spring Boot web application. I'm first quickly going to show it to you and explain its architecture. Then, we're going to introduce Spring Integration into this application to decouple the web layer from the surface layer. You will learn how to use Spring Integration in the Spring project, and I'll show you different ways to configure Spring Integration components using XML configuration, Java annotations, and the Spring Integration domain‑specific language. Spring Integration provides a number of different message channel implementations that correspond to different Enterprise Integration Patterns. We will take a look at what those are and organize them so that you have a clear overview of Spring Integration message channels. You will have a strong foundational knowledge of Spring Integration, and in the next modules, we're going to build on top of that.

### Setting up the Demo Application

To get started with Spring integration, we need a simple Spring application, so I've prepared a simple web application. Let's take a look at the starting point. The demo application has a page where people can register for the tech conference of a fictional company, Globomantics. You can choose a ticket type and then enter your name, email address, etc, and click the Register button. All it does now is save your registration in a database and show you a 'thank you' page. You can take a look at the source code of the application. It's a Spring Boot application which has a Spring Web MVC controller and a bunch of JPA entities and Spring data JPA repositories to work with the database. It has a typical layered architecture. There is a web layer that contains the Controller, then a service layer that contains the RegistrationService, and at the bottom, the database layer containing the entities and repositories. When you fill in the form and click on the Register button, then the submit method in the controller will be called, which calls the registrationService. The registration service creates the necessary entities and calls the database layer to save them in the database. To keep it simple, the database is an in‑memory h2 database. You can build and run the application yourself using your IDE or from the command line using the command mvn spring‑boot run. When it has started, point your browser to localhost port 8080. When you've entered a registration, you can use the h2‑console to look at the content of the database. Navigate to localhost port 8080/h2‑console. Use the jdbc URL, jdbc:h2:mem:globomantics, User Name sa, and no Password to connect to the database. After entering a registration, you will see that there are records in the table's ATTENDEES and ATTENDEE_TICKETS. That's our starting point. Let's now start working with Spring integration.

### Adding Spring Integration

We are now going to add Spring Integration to the demo application. We will start simple with a single Point‑to‑Point Channel and a service activator. We are going to use Spring Integration to decouple the web layer from the surface layer. At the moment, the controller, which is in the web layer, has a direct dependency on the registration service. Instead of having the controller directly call the service, we're going to make this work via a message channel. The submit method of the controller will put a message on the channel and the service will be called by a service activator to process the message. Let's see how we can do this. The first thing we have to do is add a dependency on Spring Integration to the project. There's a Spring Boot starter for Spring Integration so we will add a dependency on that starter in the Maven pom file. We will be using XML configuration for the Spring Integration components in this example. Let's add a Spring XML configuration file to the project. You can give this file any name you like. Let's name it integration.config.xml and save it in the resources directory. Now we have to tell Spring to load configuration file. Go to the SpringBootApplication class, which is class GlobomanticsRegistrationApplication. Add an ImportResource annotation to make Spring look for the XML file in the class path. That's all the setup we have to do to get Spring Integration included in our Spring Boot project. As you see, it's very easy. Now we can create Spring Integration components in the configuration file. Let's first declare the Spring Integration XML namespace and schema location. You can choose any namespace prefix you like, but int is a recommended conventional name, so let's use that. We're going to create two Spring Integration components, a message channel and a service activator. Let's create our first message channel. This is super simple. We use int:channel to create a channel and give it an ID. Let's give this channel the ID registrationRequest. Creating the service activator is just as easy. The service activator pattern is one of the Enterprise Integration Patterns. It's a simple type of endpoint that calls some business logic whenever it receives a message on the channel that it's connected to. We have to specify a few attributes on the service‑activator element here, first, the channel that it listens on. Then, we use the ref and method attributes to specify that it should call the register method of the registrationService. The value of the ref attribute is a Spring bean name, so we use the bean name of the registration service here. The value of the method attribute is just the name of the method that we want the service activator to call. Next, we have to modify the controller. Let's take a look at the class RegistrationController. We don't want the controller to directly call the registration service anymore, so we'll first remove the dependency on the registration service. We do want the controller to send a message to the channel. Let's inject the channel into the controller. The channel definition that we put in the XML configuration file registers the message channel as a regular Spring bean, so we can use dependency injection here to get it into the controller. A typical Spring Integration application has multiple message channels, and Spring Integration also registers a few special channels itself, so we have to use the Qualifier annotation here to tell Spring which message channel bean we want, which is in this case, of course, the channel with the id registrationRequest that we just created. In the submit method, we now have to first create a message, which we can then send to the channel. An easy way to create a message is by using class MessageBuilder. Let's use the withPayload method to create a message with the AttendeeRegistration object as the payload. Here's a small issue to take care of. When you're using MessageBuilder, you might notice that there are actually two classes named MessageBuilder available to import. One is in the package org.springframework.integration.support, and the other one is in the package org.springframework.messaging.support. This is a bit confusing. Which one should you use? The reason why there are two has to do with history. Originally, MessageBuilder and some other classes were part of Spring Integration, but at some point, the people developing the Spring Framework found out that a number of core messaging classes were so useful that they added them to the core Spring Framework as well. But for backward compatibility, they didn't remove the classes from Spring Integration. So now we are unfortunately stuck with classes with the same names in multiple places. My recommendation is to prefer the core spring messaging classes from the package org.springframework.messaging above the Spring Integration‑specific classes. So I take care here to import MessageBuilder from the package org.springframework.messaging.support. Now that we have a message, sending it to the channel is very simple. We just have to call the send method on the channel passing it the message. That's it. We now have our first Spring Integration application. Let's run it and see if it still works. As you can see, the application still does the same thing. When you fill in the registration form and click the Register button, the registration is still saved in the database.

### Using Java Configuration

Before we look deeper into Spring Integration message channels and endpoints, I want to show you more ways to configure Spring Integration components besides XML. As I explained in the introduction module of the course, there are several ways to configure components. Just like in regular Spring, besides XML configuration, you can also use Java annotations. Spring Integration adds a number of annotations specifically for Spring Integration components to the usual Spring Java configuration annotations. A third way is to use the Spring Integration domain‑specific language to set up integration flows. Let's look at Java configuration in more detail. We'll start with the code that we finished with in the last clip. Let's get rid of the XML configuration. Remove the XML configuration file and the @ImportResource annotation on the SpringBootApplication class. Now let's add a class named GlobomanticsIntegrationConfig and put a @Configuration annotation on it. Spring will automatically find this class and use it to initialize the application context. To create the message channel, add a method to this class with a @Bean annotation. The method will return a MessageChannel object. We'll name the method registrationRequest so that Spring will create a MessageChannel Spring bean named registrationRequest, just like we had in the previous example with XML. Now, what should we put in the body of this method? We will have to create the right kind of MessageChannel object here and return it. Note that MessageChannel is itself an interface, so we can't simply use new MessageChannel. We will have to create an instance of one of Spring Integration's message channel implementation classes here. We didn't have to do this in the last example with XML. When you use XML configuration, Spring Integration chooses a message channel implementation itself if you don't explicitly specify what type of message channel you want. The default implementation is DirectChannel, so let's use that here as well. Don't worry too much at this point about what exactly a DirectChannel is. We are first focusing on how to configure Spring Integration with Java configuration. Later in this module we will look at the different message channel implementations that Spring Integration provides and you'll learn what exactly a DirectChannel is. The second thing we had in our XML configuration was the service activator. In this example we are going to define the service activator by putting a @ServiceActivator annotation on the register method of class RegistrationService. We have to tell it what channel to listen to by setting the inputChannel attribute. That's all we have to do for our first taste of configuring Spring Integration with Java configuration. You can run the application again and see that it still works. As you can see, this is really simple. I have intentionally kept the example simple so that you understand the basics first. We will soon get to more complex and more interesting examples. In fact, before we move on to looking at the domain‑specific language, let's look at some more features of the service activator.

### Working with the Service Activator

It's worth it to spend a few minutes to take a closer look at the service activator. The registration page in the demo application shows you that you can get a ticket for an early‑bird price. This is hard coded in the HTML to keep it simple, but the registration service actually determines if you get your ticket for the early‑bird, regular or last‑minute price by looking at the pricing categories in the database. Which pricing category applies depends on when the service processes the registration. The getTicketPrice method looks up the PricingCategory using the current date. It would be more fair if the PricingCategory would be determined by the date and time when you submitted your registration instead of when the service processes your registration. It didn't matter in the demo until now, but in principle, the message that the web layer sends to the service layer might be stored on a message queue and stay there for some time before it's picked up by the service activator and processed by the service. Let's make it so that we pass the date and time of submitting the registration in the message header and see how we can work with this using the service activator. First, in the Controller, we will set a header in the message with the current date and time in the submit method. Now, look again at the registration service. How can we get at the dateTime header in the register method. Normally, the ServiceActivator component that calls the register method automatically unpacks the payload from the message and passes it as an argument to the method. In this case, the payload is an AttendeeRegistration object. I'm now going to show you two ways to get at the header value, but beware that the first way is not how you should do it. I'm only showing you the wrong way to make you aware of an important principle of the service activator pattern. The second way is much better, as you will see. Okay, the first way you can do this is by changing the argument type of the register method. We can make the method take the message itself as an argument, instead of the type of the payload. The ServiceActivator component is smart enough to understand that in that case it should not unpack the message, but pass it to the method untouched. In the method, we can now extract the header value and the payload from the message. Let's pass the dateTime header to the getTicketPrice method so that we can determine the pricing category based on the timestamp value from the header. So why is this the wrong way of doing this? One of the main principles of the service activator pattern is that it's a way to connect a message channel to business logic without requiring the business logic to be aware of the messaging system. But by making the register method of our registration service take a message object, we did make it aware of the messaging system. Also, other code that might want to call the registration service would now need to pass a message object to the register method. So even though Spring Integration allows this, this way of solving this problem really violates a core principle of the service activator pattern. Fortunately, there is a better way to do this. We can make the register method take two arguments, one for the Header value and one for the Payload. Then we add annotations to let Spring integration know how to map the header value and payload to these arguments we add Header annotation to the first argument and a Payload annotation to the second. Now we don't need to deal with getting the values from the message explicitly, giving us cleaner code. Also, other code that might want to call the registration service can just pass values directly and doesn't need to know about the messaging system.

### Using the Spring Integration DSL

The third way to configure Spring Integration components is by using the domain‑specific language. We won't cover this in detail in this course, but I do want to make you aware of this and give you a starting point to discover more by yourself. The domain‑specific language gives you a set of builders with the fluent API to configure Spring Integration flows in a concise and readable way. Let's take a look at the next example to see what it's like. The registration controller and service in this example are the same as in the previous example, except that we've removed the ServiceActivator annotation from the register method in the registration service. Instead of using an annotation, we are going to use the DSL to set up the service activator and the message channel. Let's take a look at the configuration class GlobomanticsIntegrationConfig. This is where we're going to use the DSL. First, we need to create the message channel. Just like in the previous example, we'll add a method named registrationRequest with the Bean annotation, which returns the MessageChannel object. But instead of instantiated a direct channel here directly, let's use a method from the DSL. The class MessageChannels provides a number of methods to build message channels. To create a direct channel, we'll use one of the methods named direct here and will pass it the ID of the message channel. Then we can get to let the builder create a channel and return it to us. The second thing we want to do is define an integration flow. An integration flow is really a special Spring bean that initializes a set of Spring Integration components and wires them together. We'll add a method that returns an IntegrationFlow. This method should also have Bean annotation. Inside the method, we'll use the DSL to define a flow containing a service activator that receives messages from the channel we've just defined. To use the DSL, we'll start with class IntegrationFlows. This class has a long list of methods named from to start our flow from a starting point. In this case, the starting point is the registration request channel. We can use the from method that takes the name of the channel as a string. This method returns a builder that we can use to further build a flow. This builder has many methods that we can use at this point to connect many different types of components to the channel. To connect the service activator, we will use one of the handle methods. We pass this method to registrationService and the name of the method we want the service activator to call, which is register. Finally, we call get on the builder that that's returned by the handle method to get the finished IntegrationFlow object. This is a simple example that shows only a small fraction of what you can do with the DSL, but I hope it gives you an idea of how this is useful. By chaining method calls, you can in this way define integration flows that clearly show how components are connected to each other with message channels. That's all I'll show you of the DSL for the moment. The Spring Integration reference documentation explains the DSL in much more detail, so you can look it up to learn more.

### Understanding Message Channels

Since everything in Spring Integration is about messages and message channels, it's very important to understand the different message channel implementations that Spring Integration provides. Let's organize them and get a good overview of the available message channel implementations. There are six main message channel implementations we are going to look at. There are actually a few other ones, but these six are the most common and most important ones. The other ones are really specialized implementations for less common use cases, so they are not so interesting for now. Let's start with what all the message channels have in common, they all implement interface MessageChannel. This interface is very simple. The only methods it defines are two send methods, one that takes a Message and another one that takes a Message and a timeout value. The first distinction that we can make to divide the message channels into two types is the way that messages are received. DirectChannel, ExecutorChannel, and PublishSubscribeChannel are all subscribable channels. QueueChannel, RendezvousChannel, and PriorityChannel are pollable channels. The distinction between subscribable channels and pollable channels corresponds to two Enterprise Integration Patterns, the Event‑Driven Consumer pattern and the Polling Consumer pattern. The difference will become more clear if you look at the interface's SubscribableChannel and PollableChannel, which both extend interface MessageChannel. Interface SubscribableChannel adds methods to subscribe and unsubscribe message handlers to a channel. This is how the Event‑Driven Consumer pattern works. To receive messages from a subscribable channel, you subscribe a message handler that will be called by the messaging system whenever a message is sent to the channel. Receiving messages from a pollable channel works differently. Interface PollableChannel adds two receive methods. To receive a message from a pollable channel, you call one of these methods, which blocks until a message is available or a timeout occurs. This is the Polling Consumer pattern. Another way to describe the difference is pushing versus pulling messages. A subscribable channel pushes messages to the receiver by calling the receiver when a message is available, versus a pollable channel where the receiver has to pull messages from the channel by calling a blocking receive method. Finally, a difference between these two types of channels is that pollable channels may buffer messages, while subscribable channels do not. We'll get back to that when we take a closer look at the pollable channels, but let's first look at the subscribable channels in more detail.

### Subscribable Message Channels

Okay, so let's look at subscribable channels first. Subscribable channels implement the event‑driven consumer pattern. They work by pushing messages to receivers, and they don't buffer messages. The three subscribable channel implementations can be further divided into two types. The difference between these two types is in the way they dispatch messages to their subscribed message handlers. DirectChannel and ExecutorChannel are both unicasting message channels, while PublishedSubscribeChannel is a broadcasting message channel. Just like with subscribable channels and pollable channels, this distinction corresponds to two Enterprise Integration Patterns, Point‑to‑Point Channel and Publish‑Subscribe Channel. DirectChannel and ExecutorChannel both deliver the messages that are sent to them to exactly one subscribed message handler. This is what makes them Point‑to‑Point Channels. PublishSubscribeChannel broadcasts messages that are sent to it to all its subscribed message handlers. That makes it correspond to the Publish‑Subscribe Channel Enterprise Integration Pattern. Note that it is possible to subscribe multiple message handlers to a DirectChannel or ExecutorChannel, but when a message is sent to either of these channel types, it will be delivered to only one of the handlers. Which handler gets the message depends on how you configure the channel. Finally, I can explain to you what exactly a DirectChannel is. It's the simplest possible Point‑to‑Point Channel implementation that's based on the event‑driven consumer pattern. The implementation of its send method is very simple. The only thing it does is immediately call one of its subscribers in the same thread that the send method was called. Run the first version of the demo application again, make a registration, and pay attention to the logging. There you can see the DirectChannel in action. In the logging, you see that the RegistrationService comes first, logging that it has received the message and saved the registration. After that, you see the RegistrationController logging that it has sent a message. It happens this way because when the controller calls send on the channel, the DirectChannel immediately calls the service activator to receive the message. Send and receive all happen on the same thread, as you can also see in the logging. When the service returns, the controller gets to write its log message telling you that the message was sent. ExecutorChannel is very similar to DirectChannel. The difference is that it doesn't call one of its message handlers directly in the same threat, but that it does this by running a task in an executor. This executor can, for example, be a thread pool so that you can have multiple threats handling messages concurrently and without blocking the senders thread. We will get back to publish‑subscribe messaging later in the course, so we'll save PublishSubscribeChannel for when we get there.

### Pollable Message Channels

Let's now get back to the three pollable channel implementations. Pollable channels implement the polling consumer pattern. They work by receivers pulling messages from the channel and may buffer messages. Pollable channels are all point‑to‑point channels. Multiple receivers can call the receive method of a pollable channel, but each message will be delivered to only one of the receivers. Let's briefly discuss the three pollable channel implementations. First there's QueueChannel. This is a simple message channel that stores messages in a queue. By default, it uses a LinkedBlockingQueue with an unbounded capacity. It's possible to configure the capacity or even to replace the queue implementation by some other type of queue. When receive is called on a QueueChannel, it gets the next message that's waiting in the queue or it blocks until a sender puts a message in the queue or a timeout occurs. RendezvousChannel is similar to QueueChannel, but it behaves as if it has a queue with capacity zero. This means that when a sender sends a message to this type of channel, it will block until the receiver receives the message. And also the other way around, when a receiver calls a receive on the channel, it will block until the sender sends a message. It's like the sender and receiver agreed to meet on a street corner to hand over a package. Whoever arrives first at the street corner has to wait until the other one arrives there too. PriorityChannel is also very similar to QueueChannel. The difference is that QueueChannel uses a regular first in/first out queue and the PriorityChannel uses a priority queue instead. By default, messages are ordered by looking at a special message header, unsurprisingly named priority, but it's also possible to configure custom logic to order messages. QueueChannel and PriorityChannel, by default, store messages only in memory. It's also possible to make the queues persistent, for example, by storing messages in the database, but if you need messages to be persisted, it's often better to use a message broker instead. That's what we're going to do in the next module of this course, so stay tuned for that. Now you have a clear overview of the different types of message channel implementations that Spring Integration provides. As I mentioned, it's really important that you understand message channels so that you can make the right decision for which message channel to use when.

### Summary

Let's see where we are now. We started building the demo application and decoupled the web layer from the service layer by using Spring Integration. You've learned about the different ways you can configure Spring Integration components using XML, Java annotations, and the Spring Integration domain‑specific language. We took a closer look at the service activator, which is a message endpoint that you can use to call a business logic component to handle messages sent to a channel. You also have a good grip on the different message channel implementations. The message channels can be divided into subscribable channels and pollable channels and Point‑to‑Point and Publish/Subscribe Channels. In the next module, we're going to continue with the demo application. We're going to split it into two separate applications the front end the back end, and we are going to use a message broker to handle the messaging between them. Let's continue with the next module.

# Using a Message Broker for Point-to-Point Messaging

### Overview

Welcome to the next module. The demo application that we have now consists of a single Spring Boot application with a web layer, service layer, and database layer. The web layer now sends messages to the service layer using Spring Integration. We are going to split the application into two separate applications to show you how you can use a message broker to take care of the messaging between applications. The message broker we'll be using is RabbitMQ. First, we will take a look at RabbitMQ and get it running on our computer. Then, we will take a look at how we can make the front end and the back end use it to exchange messages. Finally, we will make another change in the back‑end application so that we can run multiple instances of it. Let's start by introducing RabbitMQ.

### Introducing RabbitMQ

So, we're going to use RabbitMQ in this module. Let's take a moment to look at what exactly a message broker is, what RabbitMQ is, and how we can set it up for the demo application. In the demo application that we have so far, we have a web layer and a service layer that both run in the same process. We have somewhat decoupled them by having them use messaging with Spring Integration message channels. But what if we want to have separate processes communicate with each other using messages? Then you'll want to use a message broker. A message broker is a piece of software that provides messaging capabilities such as persistent message queues and ways to route messages from senders to receivers. In the Enterprise Integration Patterns book, each of the patterns is introduced by stating a question that the pattern being described answers. The message broker pattern is introduced with the following question. How can you decouple the destination of a message from the sender and maintain central control over the flow of messages? From this question, you can see that it's about decoupling senders and receivers, as I've already mentioned, and also about being able to monitor and manage the flow of messages in the system. We will be using RabbitMQ as our message broker. It's open source and being developed by Pivotal, the same company that takes care of the Spring Framework, so RabbitMQ is very well supported by Spring, which makes it easy to use for our demo. Let's get RabbitMQ running on our computer and take a quick look at its management interface. You can, of course, download RabbitMQ and install it on your computer directly, but I'll be using Docker to run it. You will see that this makes it super easy to run RabbitMQ. If you've never used Docker before, don't worry, we are not going to do complicated things with it, and you don't need to understand it in detail to follow this course. You don't even need to use Docker. If you prefer, you can also just download and install RabbitMQ on your computer. However, I highly recommend that you learn the basics of Docker since it's so useful for software development. I use it every day when developing software, for example, to run databases in Docker containers. The software you run in a Docker container runs in a kind of sandbox so it doesn't pollute the rest of the system, and it makes it very easy, for example, to create a new container with a fresh database whenever you need it. You can, of course, find a number of good courses on Docker at Pluralsight. To run RabbitMQ in Docker, you don't need to download or install RabbitMQ. You do, of course, need to have Docker on your computer. When you have Docker, it's just a single command to create and start a Docker container running RabbitMQ. When you do this for the first time, Docker will automatically download an image containing RabbitMQ. When this command is done, you can see that the container is running by using the command docker ps. Once the container is created, you can stop it using docker stop rabbitmq, and restart it using docker start rabbitmq. You can delete the container using docker rm rabbitmq. When you delete the container, all the data that's in it is also lost, so if you had message queues and messages in your RabbitMQ, they will be gone when you delete the container. Let's recreate and start my RabbitMQ Docker container again, and then take a look at the management interface. When it's running, you can get to the management interface by pointing your browser at localhost port 15672. Use Username guest and Password guest to log in. I'm not going to say too much about the management interface. The most interesting part for our demo is the Queues tab, so let's click that. Here, you can see an overview of the message queues. Currently, there are no queues. For our demo, we need to define one queue. In the Add a new Queue section, let's enter the name of our queue, globomantics.registrationRequest. We want this queue to be durable, which means that it will persist messages on disk and not just keep them in memory. We don't need to set any of the other options, so let's click Add queue. There's our new queue. So now we have RabbitMQ running and we've defined the queue that we need for our demo application. As I explained, when you stop and restart the Docker container, the queue will still be there, but if you delete the Docker container and recreate it later, you'll also have to create the queue again. With RabbitMQ ready, let's now take a look at how we can split the demo application into a separate front end and back end.

### Connecting the Frontend to RabbitMQ

We will split our demo application into two separate Spring Boot applications, the front end, which contains the web layer and the back end, which contains the service and database layers. We will connect both applications to RabbitMQ so that they can exchange messages. Let's take a look at the next example project. The example project is now a multi‑module Maven project with three modules, model, service, and web. The model module only contains class AttendeeRegistration, which is the data transfer object that's used in both the web layer and the service layer. It's in a separate module that both the service and web modules depend on so that we can use it in both the front‑end and the back‑end applications. The service module contains the back‑end application. It's now a separate Spring Boot application that contains only the service layer with class RegistrationService and the database layer. The web module contains the front‑end application, which is just a web layer with class RegistrationController. What our goal is now is to have the front‑end application send messages to the RabbitMQ queue that we defined and have the back‑end application receive and process the messages. Let's first see how we can get the front end to send its messages to RabbitMQ. First of all, let's take a quick look at the Maven pom file for the front‑end application. I've added a dependency there on spring‑integration‑amqp. AMQP, which stands for Advanced Message Queuing Protocol, is a standard protocol that applications use to work with message brokers, including RabbitMQ. By including this dependency, Spring Boot will automatically configure a number of Spring beans that we need to connect to. RabbitMQ. Next, let's take a look at class GlobomanticsWebApplication, which is the Spring Boot application class for the front‑end application. For this demo, we are using XML configuration, so I've added an ImportResource annotation here to include the XML configuration file. Let's see what we need to configure there to get the front end to send its messages to RabbitMQ. We'll need to define a few Spring Integration components here. First, the registrationRequest channel. That's the channel that the controller will send a message to when you submit the registration form on the webpage of the application, just like we had in earlier versions of the demo. Remember that the messages that the controller sends have an AttendeeRegistration object as the payload and a dateTime header containing the date and time the registration was submitted. In the previous version of the demo, such a message was delivered to the service layer by a service activator that listened on the channel and that got the payload and header from the message and passed it to the registration service. In this new version, we want to send this message to RabbitMQ. To be able to do this, we need to convert the payload to a suitable format. There are, of course, many formats that you can choose to use. You could, for example, use Java serialization, but this has drawbacks. A serialized Java object is a binary blob of data, which is not easily human readable, and another problem with Java serialization is that it's tightly coupled with a specific version of a Java class. If you make changes to the class, then you might get an IncompatibleClassChangeError when you try to read an object that was serialized with an older version. So it's better to use a human‑readable standard format. Let's use JSON here. We'll define an object‑to‑json‑transformer, which Spring Integration conveniently has available for us. It will receive messages from the registrationRequest channel, convert a payload to JSON, and send the converted messages to a new channel, which we'll call toRabbit. To get the messages that are sent to this channel to RabbitMQ, we are going to use an outbound channel adapter. The Channel Adapter pattern is another Eenterprise Integration Pattern. Channel adaptors are the glue between Spring Integration message channels and other components and systems and are a very important part of Spring Integration. One of the main features of Spring Integration is that it comes with many different channel adapter implementations, which allow you to connect to many different types of systems. To connect to RabbitMQ, we are going to use an AMQP outbound channel adapter. Spring Integration AMQP has its own XML namespace to define AMQP‑specific components, so we'll first add that namespace to the header of the XML file. Then, we can define the outbound channel adaptor. We will have to set a few attributes on the channel adapter. First, the channel that it should receive messages from, which is the toRabbit channel. Next, we have to set the amqp‑template attribute. The amqp‑template bean is a Spring bean that's used to connect to the message broker. It's similar to a Spring JdbcTemplate or RestTemplate that you use to connect to a database or a REST web service. Because we have a dependency on spring‑integration‑amqp in this project, Spring Boot automatically creates a Spring bean named rabbitTemplate to connect to RabbitMQ that we can use here. In the Spring Boot application properties file, there are a number of properties that you can set to configure the connection to RabbitMQ. These settings are used by Spring Boot to configure the Rabbit template. They are configured here to point to RabbitMQ that's running on the local machine. The last attribute we have to set on the outbound channel adapter is the routing key. This tells RabbitMQ which queue the message should go to. In this case, it's just the name of the queue we created in RabbitMQ named globomantics.registrationRequest. That's it. Let's see it in action. Let's start the front end by running class GlobomanticsWebApplication. We can now navigate to the registration page again, fill in the form, and click the Register button. Now let's take a look at the RabbitMQ management interface again and click on the queue. You can see that there is now a message on the queue, and you can also look at the content of the message. As you can see, it contains an attendee registration message in JSON format. Notice that we have now really decoupled the front end and the back end of the demo application. We don't even need to have the back end running to be able to use the front‑end application. As long as there's nothing receiving messages from the queue in Rabbit MQ, the messages will just stay there. This shows you one of the big advantages of asynchronous messaging. You can take down the back‑end service and it's still possible to register, and the registrations will wait in the queue until the back end is available to process them. Next is, of course, changing the back end so that it can receive messages from RabbitMQ.

### Connecting the Backend to RabbitMQ

There's a message waiting in the queue for the back end, so obviously we now need to connect the back end to RabbitMQ so that it can process this message. This is very similar to what we've just done with the front end. The SpringBootApplication class for the back end is class GlobomanticsServiceApplication. Just as in the front end, we will configure the necessary Spring Integration components using XML, so there's an ImportResource annotation here to include the XML configuration file. To receive messages from RabbitMQ, we will use a channel‑adapter again. Since we are now receiving messages, we will use an inbound‑channel‑adapter. Using the queue‑names attribute, we tell it that we want to receive messages from the queue named globomantics.registrationRequest. Note that IntelliJ displays this queue name in red, because for some reason it thinks that this name should be the name of a Spring bean, but that's wrong. It looks like that's a small bug in IntelliJ. Next, we tell the channel‑adapter to put the messages that it receives on the Spring Integration channel named fromRabbit, which we will also have to define. The messages that we're receiving on the fromRabbit channel have a JSON payload. Let's add a json‑to‑object‑transformer, the opposite of the object‑to‑json‑transformer that we used in the front end, to translate the JSON payload back to an AttendeeRegistration Java object. We'll let the transformer send its output messages to a channel named registrationRequest. Finally, we will define a service activator that receives messages from the registrationRequest channel and that calls the register method on the registrationService, just like we had previously. Let's start the backend application. In the login, you'll see that it has received a message from RabbitMQ immediately after starting up and that it has saved the registration in its database. You can connect to the h2‑console, which is now running on localhost port 8081, and see that the registration is in the database. So there we are, we now have a separate frontend and backend application that can exchange messages via Rabbit MQ. In this example project, I've used XML configuration. As you've learned earlier, Spring Integration provides different ways to configure components, with XML, Java annotations or the Spring Integration domain‑specific language. There are pros and cons to each of these options. I've used XML here because it was clear and simple for this example. The Spring Integration namespace parsers, which convert your XML configuration to Spring beans, do a lot of work for you under the hood to set up everything correctly. As a bonus, I've also included a version of the example project that we have worked with in this module with Java configuration instead of XML in the examples that you can download with his course. I'm not going to explain it in detail here, but you can take a look at it yourself to learn what you would need to do if you would want to use Java configuration instead of XML. You will see that it's a bit more involved since there are some components that you'll have to configure yourself that are configured automatically for you when you use XML. You will have to have a better understanding of the Spring Integration components to do this. I've added comments to the source code to explain it as well as I can.

### Running Multiple Instances of the Backend

We've now completely decoupled the front end and back end using RabbitMQ. As a consequence of this, we no longer have to have both the front end and the back end running to be able to enter and process attendee registrations. There's another advantage to this as well. We can now also scale the front end and back end independently. For example, we can have multiple instances of the back end running to process registrations. As the last demo in this module, let's see how we can have one instance of the front end running and two instances of the back end. Let's take a look at the next example project. In the back‑end application, we are using an embedded in‑memory H2 database. This means that the database is running inside the back‑end application itself and doesn't store registrations on disk, but only in‑memory. When we stop the back‑end application, the database and all the data it contains disappear. Now we want to be able to run multiple instances of the back‑end application, and we want them to use the same database, so we're going to change the database configuration of the back end to make it work with an H2 database running in a separate process. To make it easy to run the database separately, I've created a small and simple Docker image and made it available on Docker Hub. There seems to be no official Docker image for the H2 database, so I've made one myself. With the following command, you can start H2 in a Docker container. The H2 console will be available on localhost port 8082. Now there are two things we have to do in the back‑end application. First, edit the Spring Boot application properties to make it access the H2 database running in Docker instead of creating an embedded in‑memory database. Second is to remove the schema.sql and data.sql files from the src/main/resources directory because we don't want the back‑end application to try and create the schema and insert data every time when it starts up. We do have to make sure to run the SQL commands in these two files once on the H2 database running in Docker so that the schema exists and the data is inserted. Let's now in one terminal window, start up the front‑end application using mvn ‑pl web spring‑boot:run, and then start two instances of the back‑end application using mvn ‑pl service spring‑boot:run in two other terminal windows. Both of these instances of the back‑end application will connect to RabbitMQ and listen to the same queue. Since the queue does point‑to‑point messaging, whenever the front end sends a message to the queue, RabbitMQ is going to deliver it to only one of the instances of the back‑end application. Enter some registrations in the web application. Look at the logging of both instances of the back end. You will see that sometimes number one processes the registration and sometimes number two. Use the H2 console on localhost port 8082 to see that both instances are saving registrations in the same database. As you can see, it's now easy to run multiple instances of the back‑end application to process registrations.

### Summary

In this module, we've used Rabbit MQ to handle the messaging between the front end and back end of our demo application. You've learned what a message broker is, and you've seen the advantages it brings. Because the front end and back end are now decoupled, we have a much more flexible system. You've learned that you can use channel adapters to connect Spring Integration message channels to systems such as RabbitMQ. So far, we have used message channels and a RabbitMQ queue for point‑to‑point messaging. In the next module, we're going to expand the demo application more, and you'll learn about the other major messaging pattern, publish‑subscribe messaging. We will also use more channel adapters to connect to other kinds of systems. Let's continue in the next module.

# Implementing Publish-Subscribe Messaging

### Overview

There are two main Enterprise Integration Patterns that describe how senders and receivers exchange messages, point‑to‑point messaging and publish/subscribe messaging. So far, we have worked with point‑to‑point messaging. In this module, we're going to look at publish/subscribe messaging. First, we'll go through a bit of theory so that you understand exactly what the differences between the two messaging patterns and when to choose which when you're designing a messaging application. Then, we'll extend our demo application again. You will first learn how to add and configure a publish/subscribe channel, and then we'll add two subscribers. When we are done, our demo application will be able to send a confirmation email to the attendee and notify the Globomantics billing system that an invoice needs to be sent for the ticket. Let's start by looking at the difference between point‑to point‑messaging and publish/subscribe messaging.

### Publish-Subscribe Messaging

Earlier in the course, you've learned about the different types of message channel implementations that Spring Integration provides. Remember that we had subscribable message channels and pollable message channels, which could further be divided in point‑to‑point channels and publish‑subscribe channels. There are three subscribable message channel implementations, which are DirectChannel, ExectuorChannel, and PublishSubscribeChannel. The first two of these are point‑to‑point channels, which means that each message sent to such a channel is received by exactly one receiver. A point‑to‑point channel can have multiple receivers, but each message is delivered to only one of the receivers. A publish‑subscribe channel on the other hand, broadcasts messages that are sent to it to all of its receivers. So when a message is sent to a publish‑subscribe channel, a copy of the message is delivered to each of the subscribed receivers of the channel. The most common use case for publish‑subscribe channels is to broadcast event notification messages. That's also how we are going to use it in our demo application. Currently, the only thing the registration service does is store a registration in the database. What we are going to do is have the registration service return an object that represents a registration event. It will be sent to a publish‑subscribe channel so that other components can take action whenever a registration is made. Another more subtle difference between point‑to‑point channels and publish‑subscribe channels is in the degree of decoupling of senders and receivers. A point‑to‑point channel already provides a way to decouple the sender from the receiver. The sender doesn't need to know who the receiver is that's going to process the message that it sends to its point‑to‑point channel. However, when you're designing a messaging application and you're using a point‑to‑point channel, you likely already have in mind what receiver will be processing the messages, and you'll design the payload of the message is specifically for that receiver. A publish‑subscribe channel provides an even higher degree of decoupling between sender and receivers. When you use a publish‑subscribe channel, multiple different receivers will probably receive the message, so you'll tend to design the message payload in a more generic way. This high degree of decoupling makes it easy to extend the system later with new types of receivers to handle the messages on the publish‑subscribe channel. Most likely the only thing you need to do is write code for the new receiver and subscribe it to the channel, and you won't need to change the sender or the content of the messages. When deciding whether to use a point‑to‑point channel or a publish‑subscribe channel, the question it comes down to is should only one receiver process the message or does it make sense if multiple receivers may process the message. The answer often depends on what role the message plays in the application. Messages can have different roles. For example, a message may play the role of a command where the sender sends the message to tell the receiver to execute some action. A message can also represent a piece of data which is, for example, sent as a reply to a query. A third type of message represents an event to notify receivers that an event has happened in the system. These three roles correspond to three Enterprise Integration Patterns, which are the Command Message, Document Message, and Event Message patterns. When deciding what kind of channel to use, you will find that if your message represents an event, a publish‑subscribe channel is the best choice most of the time. On the other hand, if a message represents a piece of data or a command that must be executed, a point‑to‑point channel is often more suited. There is, however, no exact recipe to make the decision, and ultimately, it comes down to a design choice. It's time to bring the theory into practice. Let's see how we can implement publish‑subscribe messaging in the Globomantics application.

### Configuring a Publish-Subscribe Channel

Let's continue with a demo application. We're going to have the registration service return an object that represents a registration event, and we'll add a publish‑subscribe channel where the registration events will be sent to. I'm starting with the code from example 5. First, let's add a class that represents a RegistrationEvent. We'll add it to the model next to class AttendeeRegistration. The RegistrationEvent class is just a simple Java object with some fields with getters and setters containing information on the registration that has been made. It contains the ticket type, which is premium, standard, or community, the ticket price, the unique code for the ticket, and the name and email address of the attendee. Next, we'll modify the register method in class RegistrationService. Right now it returns void, but we'll make it return a RegistrationEvent object instead. At the end of the method, we'll have to create a RegistrationEvent object, fill it with data from the registration that was saved in the database, and return the object. The register method is called by the service activator that we have configured in the Spring Integration XML configuration file. There we'll have to specify what happens with the event object that the service returns. We can add an output‑channel attribute to the service activator with the name of the channel that we want the event object to be sent to. Now, we, of course, have to define that channel. To define a publish‑subscribe channel, we'll add an int:publish‑subscribe‑channel element to the configuration. Let's give it a name, registrationEvent, and now we can make the service activator point to this channel. That was all for the first step. Now, we, of course, want to register receivers on this channel. That's what we're going to do next.

### Sending a Registration Confirmation Email

When someone registers for the Globomantics tech conference, we want them to receive a confirmation email when their registration has been saved. So let's add a listener to the registration event channel that sends a confirmation email. You will learn a few new things here, creating a chain of message handlers, using a header enricher, and using an outbound channel adaptor for sending email. Let's continue with the code where we left off. To be able to use the Spring Integration outbound channel adapter for email, we'll first have to add some dependencies to our project. Support for integrating with different types of systems is organized in separate libraries in Spring Integration so that you can choose to include exactly those libraries that you need for your application. We had already included spring‑integration‑amqp to connect to RabbitMQ, and now we'll add spring‑integration‑mail to connect to a mail server. The Spring Integration Mail library also expects us to include an implementation of the JavaMail API in our project. Let's use jakarta.mail version 1.6.4, which is the current version of the reference implementation of JavaMail under Eclipse's Jakarta EE project, which is a successor to Oracle's Java EE. Now let's get back to the Spring Integration XML configuration file and add the necessary components. First, we'll add the namespace declaration for Spring Integration Mail so that we can use the components that this library provides in our configuration file. Our goal is to add an outbound channel adapter that listens to the registrationEvent channel, and that takes a RegistrationEvent message and turns it into an email that's sent to the attendee. Spring Integration Mail has an outbound channel adapter that we can use by adding an int‑mail:outbound‑channel‑adapter element to the configuration. On this outbound‑channel‑adapter, you can set a number of attributes. We can set the channel attribute to connect it to the registrationEvent channel. There are also attributes to tell it which mail server to send email to. For now, let's set these attributes to localhost port 3025, username globomantics, and password globalmail. We'll come back to these settings later. Just adding the outbound channel adapter like this is not enough. It's going to receive RegistrationEvent objects from the registrationEvent channel, but the channel adapter doesn't know by itself how to create an email out of a RegistrationEvent object, so we'll have to add some components between the channel and the outbound channel adaptor to transform registrationEvent messages into emails. Let's add a transformer that listens to the registrationEvent channel, and that transforms RegistrationEvent objects into emails. We'll pass the output of the transformer to the outbound channel adapter. Just like the service activator, the transformer has a ref and method attributes that point to a method in a Spring bean that does the actual transformation. I've added a class confirmationMailTransformer with a method named toMailText, which takes a RegistrationEvent object and returns a string containing the body of the email that we want to send. Before we continue with connecting the output of the transformer to the outbound channel adapter, let's talk about message handler chains. With what you've learned so far, what you would probably do to connect the transformer to the outbound channel adapter is define another channel, that's the output for the transformer and the input for the channel adapter. That would work, but you can imagine that if you have a more complicated application with lots of components, you would also have to define lots of channels to connect all these components. To avoid having to define so many channels, you can define a chain. A chain groups message handlers together that will be called in sequence, just as if you would have defined direct channels between the message handlers. Let's put the transformer and the outbound channel adapter together in a chain. We'll add an int:chain element. Let's give it an id confirmatioEmailChain. We'll move the transformer and the channel adapter into the chain. Instead of having the handlers in the chain listen to a channel directly, we'll make the chain listen to the registrationEvent channel. We can remove the input‑channel and channel attributes from the transformer and the channel adapter. The chain will pass messages it receives to the first handler and pass the output of each handler automatically to the next one. So, in this case, it will send registrationEvent messages to the transformer and the output of the transformer to the channel adapter. Using a chain is useful if you have a sequence of message handlers that are related and always have to run in the same order. It helps you to organize your configuration file and not have to explicitly define channels to connect up all the handlers. There's one thing that's still missing here. The transformer creates the body of the email from a RegistrationEvent object, but we also have to tell the channel adapter the email address to send the email to and the subject line of the email. The outbound channel adapter can get this information from the headers of the messages that it receives. We'll add another component to the chain, a header enricher. Spring Integration Mail has a header‑enricher component that we can use to set message headers that the outbound channel adapter understands. We'll set three message headers. First, the from header with the email address of the sender of the email. Then, the to header. We want to get the value for this header from the RegistrationEvent object. We'll use the expression attribute to get this. In this expression, the keyword payload refers to the payload of the message we're working with, which is, in this case, a RegistrationEvent object. So payload.attendeeEmail gets us the email address of the attendee that we want to send the email to. Finally, the subject header sets the subject line for the email. Now we're ready. We have a publish‑subscribe channel with so far a single receiver, which is the confirmationEmailChain. The chain contains three message handlers that set the headers of the message, transform the payload into text, and send the email. To run this, you'll need to have a mail server. If you have a mail server that you can use, then you can, of course, set the host, port, username, and password on the outbound channel adapter to use that mail server. If you don't have a mail server, then you can run GreenMail in a Docker container. GreenMail is a very small and simple mail server that's meant for testing purposes, which is perfect for us here. You can start it with a command like this. It will use port 3025 for outgoing mail using SMTP and port 3143 for IMAP. With GreenMail running, you can now run the front end on the back end of the demo application and enter a registration. After the registration is saved, a RegistrationEvent message is sent to the registrationEvent channel, and a confirmation email will be sent. If you want, you can configure an email client to receive the email from GreenMail by pointing it to localhost port 3143 and using IMAP. Another way to read the email that's been delivered in GreenMail is by using the curl command. With the following command, we can check how many messages there are in the inbox. The output also tells you the ID of the first unread email. You can read an email with the following command, where the number after UID is the ID of the email that you want to read. Of course, the point of publish‑subscribe messaging is that multiple receivers receive the messages sent to a publish‑subscribe channel. Let's add another listener to the channel.

### Connecting the Billing System

Besides sending an email, we also need to let the Globomantics billing system know to send an invoice for the ticket. Let's imagine that the billing system has a web service that we need to call for this. We're going to add another listener to the publish‑subscribe channel that will call the billing system web service when a registration event happens. First of all to simulate the billing system, I've added another module to the demo application. This contains a very simple Spring Boot application with a class BillingController with just one method, which accepts HTTP POST requests. It doesn't really do anything besides writing a log message when it's called. The billing application is configured to listen on Port 8083. Let's see what we need to do in the service module to call the billing web service. We're going to use an HTTP outbound channel adapter to do this. Just like with AMQP and mail, the HTTP outbound channel adapter is in its own Spring Integration library. We have to add a dependency on spring‑integration‑http to be able to use it. Also, just like the other libraries, it has its own XML namespace, so we have to add the namespace declaration to the header of our Spring Integration configuration file. Now, let's add the HTTP outbound channel adapter. Just like in the previous clip, I'm going to put it inside a chain. So let's first define a chain with id billingChain that listens to the registrationEvent channel. Inside the chain, I'll add int‑http:outbound‑channel‑adapter element. To configure it, we have to set the url attribute to http://localhost:8083 and http‑method to POST. Just like with the outbound channel adapter for sending email, we have to do some processing before we pass the registrationEvent message to the channel adapter. We'll need to add a header enricher, which sets the contentType to application/json. Note that we are using the common header enricher from the int namespace here, not one that's specific to Spring Integration HTTP. That's all we need to do. The HTTP outbound channel adaptor will pick up the contentType header and automatically understand that it has to convert the RegistrationEvent object to JSON and send it to the billing system using an HTTP POST request. To run the complete example, we will have to make sure that all the parts are running. First, make sure that RabbitMQ and GreenMail are running in Docker containers. Then, start up the billing service and the front end and back end of our demo app. When you now enter a registration, you will see that the front end sends a message to the back end via RabbitMQ, and then in the back end, the registration is saved in the database, and the registration event is sent to the publish‑subscribe channel. From there, it's received by the confirmation email chain, as well as the billing chain, which will send an email and call the billing web service. You can find a complete code for what we've built so far in example project 8. Take a look at the code yourself and play with it and make sure that you understand how it works.

### Summary

Let's do a quick recap to see where we are now. In the previous modules, you've learned about Enterprise Integration Patterns and Spring Integration, and you've learned how to use point‑to‑point channels and RabbitMQ. In this module, you've learned about publish‑subscribe messaging. You've seen how you can create a publish‑subscribe channel and how you can connect listeners to it. You've also learned how to use message handler chains and how to use outbound channel adapters for connecting to mail servers and web services via HTTP. The demo application has become more interesting now with a message flow that starts with the registration being entered in the front end and ends with a confirmation email and a notification to the billing system. One subject that we haven't paid much attention to yet is what happens when errors occur. As long as nothing unexpected happens, our demo application works fine. To complete the demo, it's however important that we also think about error scenarios. That's what we'll be looking at in the final module of the course.

# Handling Errors

### Overview

We now have a nice demo application that can process registration messages by saving a registration in the database, sending a confirmation email to the attendee, and notifying the billing system. This all works fine as long as nothing goes wrong. In the real world, however, things do sometimes go wrong, so our software has to be prepared to deal with errors and unexpected situations. In this module, we'll investigate different error scenarios and see how the application reacts. For example, what happens if an error occurs when we are inserting a record in the database or if the mail server or the billing system are unavailable? We'll look at how we can deal with these situations in different ways. First, we will look at how we can have RabbitMQ reroute messages that cannot be processed to a dead letter queue. Finally, we will use Spring Integration's error handling mechanisms to get more fine‑grained control over errors that happen in the components of our integration flow. While we are doing this, you will also learn more about how Spring Integration uses threats and transactions. Let's start by checking out different ways things might go wrong in our demo application.

### Investigating Error Scenarios

Before we get into how we can handle errors, let's investigate some things that might go wrong and see how the demo application we have so far reacts in these situations. The first scenario is about what happens when an error occurs when we insert data into the database. The database has a unique constraint on the email address of the attendee so that when the same email address is used twice to make a registration, an exception occurs in the registrationService. Let's try this to see what happens. I've started RabbitMQ and GreenMail in Docker and the front end, back end, and billing service in IntelliJ. I enter a registration on the web page. Everything is fine and I can see in the H2 Console that the information about the attendee and ticket is saved in the database. Then I enter another registration with the same email address. Watch the logging of the back end after I click the Register button. It starts printing out error message continually, so it looks like the back end is not handling this in a good way. Let's stop it and think about what's happening. Let's walk through the integration flow, starting from the AMQP inbound‑channel‑adapter, and think about what happens when the registrationService throws an exception. The AMQP inbound‑channel‑adapter is where the flow starts. Behind this channel adapter is a message listener that receives messages from the RabbitMQ queue that we've configured. Whenever it receives a message, it puts it on the Spring Integration channel named fromRabbit, then it goes through a transformer to another channel and then to the service‑activator that calls the registrationService. The registrationService tries to insert records in the database, and then an exception occurs because it cannot insert an attendee with the same email address twice. Where does this exception go? To understand this, you have to look at how threads are used here by Spring Integration to call the message handlers in our flow. Why do we have to consider how threads are used? As you know, when a Java method throws an exception, it will go up the call stack of the current thread to the first caller in the hierarchy that has a catch block to handle the exception. In the integration flow of the demo application, we are using direct channels and also a publish‑subscribe channel. Both these types of channels call receivers in the same thread as the sender. Think back to when you learned about DirectChannel. When a sender calls send on a DirectChannel, it immediately calls receive on the message handler that's subscribed to the channel. So the receiver runs on the same thread as the sender. The same thing happens with PublishSubscribeChannel, it also runs the handlers that are subscribed to it on the sender's thread. Now we can explain what happens if the receiver throws an exception. Since it's running on the same thread as the sender, the exception goes back to the sender. In other words, the send method that the sender called to send a message to the channel will throw the exception that the receiver threw. Let's look at our integration flow again to see what this means here. The register method of the registrationService throws an exception, which goes back to the json‑to‑object‑transformer and then goes back to the AMQP inbound‑channel‑adapter. The way the AMQP inbound‑channel‑adapter by default handles this exception is by sending a negative acknowledgment back to RabbitMQ. RabbitMQ will then put the message back on the queue. Then the application will try to get the next message from the queue, which is the message that was just put back, and try to process it again. But of course then the same error occurs and the back end service starts spinning because it continually tries to process the same message that causes an error. Let's now consider another error scenario. What happens if the billing system is unavailable? Let's purge the RabbitMQ queue to get rid of the message that can't be processed and then restart the back end and stop the billing service. Now, we'll enter a registration again. Watch the logging of the back end again when I click the Register button. It will start spinning with error messages again. This time it goes wrong in almost the same way as in the first scenario, but the exception just happens a bit further down the integration flow. Note that the registration was saved in the database and a confirmation email has been sent, but then the outbound‑channel‑adapted to talk to the billing service threw an exception, which went all the way back up to the AMQP channel adapter. From there, it goes wrong in the same way as in the first scenario, the message is negatively acknowledged, put back onto the RabbitMQ queue, and then retried. Then it goes wrong in the same way as in the first scenario because the second time around there is already a record in the database for the attendee's email address. When the mail server is down a very similar problem occurs, but then it's the mail outbound‑channel‑adapter that throws the exception. Now that you understand how things can go wrong, let's see how we can make the application deal with these problems.

### Setting Transaction Boundaries

In the error scenarios where the email server or the billing services down, you might have noticed that the registration is still saved in the database, even though the message is given back to RabbitMQ. This happens because currently, the transaction boundary for the database transaction is only around the RegistrationService. Remember that we had a Transactional annotation on the service. The transaction starts when the register method is called and commits when the register method returns. So when an error occurs while sending email or calling the billing service after the RegistrationService, the database transaction has already committed. What if we want the database transaction to be committed only whenever a message has been handled completely without errors through the whole flow and rolled back whenever an error occurs anywhere in the flow? It's possible to make the AMQP inbound channel adapter participate in the transaction, and since this is the entry point of the flow, it puts the transaction boundaries around the whole flow. To make this work, we have to set two attributes on the AMQP inbound channel adapter. We have to add channel‑transacted=true and transaction‑manager=transactionManager. Note that the name transactionManager refers to the default PlatformTransactionManager bean that Spring Boot has initialized, and that's also used by Spring Data JPA, which we used to access the database. What happens now when we run this is that the AMQP channel adapter will start a transaction, and when the RegistrationService is called, it will participate in the existing transaction. The transaction now finishes with a commit or rollback after the whole flow. This means that when the mail outbound channel adapter or the HTTP outbound channel adapter for the billing service throws an exception, the database transaction will be rolled back so that we don't get records in the database for messages that have not been completely handled successfully. A side note, transactions in Spring are normally thread‑local, so this all works because in the whole flow, we are only using channels that execute their receivers in the same thread as the sender, as I mentioned in the previous clip when I explained where exceptions go that are thrown by a receiver. Making the AMQP channel adapter start the transaction was, however, just the first step. There are still some problems we have to solve. When an exception occurs in the flow, the message is still being negatively acknowledged to RabbitMQ and put back on the queue so that the back end starts trying to process the message again continually. In the next clip, we'll see how we can deal with that problem. Another problem is that not all of the components in the integration flow participate in the transaction. The mail server and the billing service are not transactional systems. When an error occurs while calling the billing system, the email has already been sent, and that can't easily be undone. We now have a particularly undesirable situation. When I run the demo application without the billing service and enter a registration, then the message will continually be retried, but at each try and email is being sent. After just a few seconds, it will have spammed the attendee with hundreds of confirmation emails. We'll definitely have to do something about that.

### Using a Dead Letter Queue

Let's take a look at one possible way to solve the problem that the back‑end server starts to spin, trying to reprocess a message that causes an error. There is an Enterprise Integration Pattern that's about dealing with messages that cannot be processed, which is the Dead Letter Channel pattern. The idea is that when the system detects a message that it cannot process for some reason, that message is put aside on a special channel so that it doesn't get in the way for processing other messages. RabbitMQ supports this pattern as follows, you can have it automatically send messages that are negatively acknowledged to a dead letter exchange, which routes them to a Dead Letter Queue. A system administrator or another piece of software can then examine the messages on the Dead Letter Queue. Explaining RabbitMQ in detail is outside of the scope of this course, so I won't explain the configuration we'll be doing in RabbitMQ in detail. It is, however, important that you know about the Dead Letter Channel pattern because it's a common way to deal with problem messages in messaging applications. What we want to achieve is that when an exception happens in our integration flow, the message that causes the problem is not put right back onto the queue so that it's immediately processed again, but instead that it's put on a Dead Letter Queue. Let's start by making a small change in the demo application. The AMQP inbound general adapter has an error handler attached to it that is used to handle exceptions that might occur when it sends messages into the Spring Integration Flow. The default error handler will send a negative acknowledgment to RabbitMQ or most types of exceptions, which will cause RabbitMQ to put the message back onto the queue. Let's replace the default error handler with our own error handler so that we get more control over what happens. We can do that by adding an error‑handler attribute which points to a Spring bean that implements interface ErrorHandler. I've defined a class registrationErrorHandler, which is our custom error handler. A simple thing we can do in the handleError method is wrap any exception in an AmqpRejectAndDon'tRequeueException. This is a special exception that the RabbitMQ message listener will respond to by telling RabbitMQ to drop and not requeue the message. When we now run the application without having GreenMail running, and we try to submit a registration, an exception will, of course, still be logged in the service application, but it will not start spinning. So we've solved the spinning problem, but now the message that caused the problem just disappears. Let's see how we can make RabbitMQ put it on a Dead Letter Queue. For this, we have to do some configuration in the RabbitMQ management application, so go to localhost port 15672 and login with username guest and password guest. First, we'll have to create a dead letter exchange. Go to Exchanges, under Add a new exchange, enter the name globomantics.dlx, select type fanout, click Add exchange. Next, we'll create a Dead Letter Queue, which we will bind to this exchange. Go to Queues, under Add a new queue, enter the name globomantics.dlq, click Add queue, then click on the name of the queue in the table. Under Bindings and Add a binding to this queue, enter the name of the exchange, which is Globomantics.dlx, and click Bind. Finally, we'll recreate our registration request queue and make sure that the dead letter exchange is set to the exchange we've just created. Go back to Queues. Delete the globomantics.registrationRequest queue. Create the queue again. Under Add a new queue, enter the name. Then click on Dead Letter Exchange, which will add an argument. For the value of the argument, enter globomantics.dlx, which is the name of the dead letter exchange. Then click Add queue. Now let's run the application again, still without having GreenMail running, and enter a registration again. Now you will see that after a few seconds, the message appears on the Dead Letter Queue. You can even get the message to inspect its content. Before we continue, let's recap the most important learning points of this model so far. All the message handlers in our integration flow are executed on the same thread because of the types of message channels that we've used. This has consequences for what happens with exceptions that are thrown by message handlers. Exceptions go back all the way to the RabbitMQ message listener. We have to be careful to configure the error handling on the message listeners so that messages that cause problems are handled appropriately. We also have to think about transaction boundaries. Transactions in Spring our thread‑local, which means that two pieces of code that are running in different threads don't share a transaction. In this example, because the whole flow runs on the same thread, we can set the transaction boundaries to include the entire flow. If we have non‑transactional systems in our flow, such as the mail server and the billing system, then using transactions is not going to prevent undesired behavior when errors occur. Sending an email or calling the billing service will not be undone when an error occurs. In the second part of this module, we'll take a look at a different approach to handling errors in the integration flow, which will give us more fine‑grained control to handle errors that happen in specific message handlers.

### Using the Error Channel

In the examples you've seen until now in this module, we've used channels that call their receivers on the same thread as the sender. That might not always be how you'll want to do things in your integration flow. Sometimes you will want to use an ExecutorChannel to make listeners run on threads from a thread pool or a QueueChannel to be able to buffer messages before processing them. When you use these types of message channels and the message handler throws an exception, then where does it go? It can't be thrown back to the sender directly because the message handler is running in a different thread. Spring Integration has a mechanism for this. What happens is that the original message that the handler was processing is packaged together with the exception in an ErrorMessage object, which is sent to a special error channel. Spring Integration automatically creates a PublishSubscribeChannel with the name errorChannel for this purpose. By default, Spring Integration subscribes a LoggingHandler to this channel, which just logs the exception that occurred. You can of course subscribe your own handlers to this channel to handle errors. If necessary, you can also define a channel named errorChannel yourself, which will override the default error channel that Spring Integration provides. Let's see how we can use this in the demo application. The fromRabbit channel that we have now is a simple DirectChannel. Whenever the AMQP inbound‑channel‑adapter sends a message to this channel, it runs its receiver, which is json‑to‑object‑transformer, and the rest of the integration flow on the same thread. Suppose that we would want to run the integration flow on a thread from a thread pool. Let's add a task executor bean that manages a number of threads, then let's add an int:dispatcher element to the fromRabbit channel that refers to this task executor. Doing this makes the fromRabbit channel an ExecutorChannel instead of a DirectChannel. Now the handlers in the flow, starting from the fromRabbit channel, will run on one of the threads of the thread pool instead of on the RabbitMQ message listener's thread. I can now remove the error‑handler attribute on the AMQP inbound‑channel‑adapter because it's not useful anymore. Exceptions will not cross thread boundaries, so the error handler that we've set here will not be called anymore to handle exceptions that occur in the message handlers. Changing the threading model also has consequences for the transaction boundaries. Since transactions are thread local and the RabbitMQ listener and the registrationService now run in different threads, they will not be participating in the same transaction anymore. The RabbitMQ listener and the registrationService will each have their own independent transactions in their own threads. Since the transaction for the RabbitMQ listener is now not useful anymore, I can just as well remove the channel‑transacted and transaction‑manager attributes from the inbound‑channel‑adapter. Whenever an exception occurs in one of the handlers of the integration flow, what happens now is that an ErrorMessage will be sent to the errorChannel. Let's run the application, cause an error, and look at the logging. Let's stop the billing service and then enter a registration. If you look at the logging of the service application, you'll see the following. You'll see a DEBUG message that shows that a message is being sent to the errorChannel. Then the LoggingHandler that Spring Integration, by default, subscribes to the errorChannel is executed, which logs the error, including the stack trace of the exception that occurred. To handle errors in an appropriate way for your application, you can subscribe your own handlers to the errorChannel that do whatever is needed. For this example, let's add an exception‑type‑router. This is a router that listens on the channel, looks at the exception type in error messages on the channel, and then decides what other channel to pass the message on to. We'll add an exception‑type‑router that recognizes data access exceptions, mail send exceptions, and resource access exceptions and passes them on to three separate channels. These three exception types correspond to the exceptions that occur when a database error occurs and when an error happens when sending email or sending a request to the billing service. Let's stop at this point. I could of course now add more components that listen to the three different error channels, but I think you now understand enough about how the error channel works.

### Summary

Considering how to deal with errors and unexpected situations is essential for any piece of software. In this module, we looked at different ways you can deal with errors in the Spring Integration application. We've looked at how you can configure an error handler on the AMQP inbound channel adapter to prevent it from requeueing a message, which causes an error, and how we can configure RabbitMQ to move such a message to a dead letter queue. We've also discussed how you can handle errors when the message handlers in your application are not running on the same thread as the sender. In that case, error messages are sent to an error channel from where you can handle them appropriately. Besides error handling, you've also learned to be aware of how Spring Integration uses threads and what consequences this has for propagating exceptions and also for transactions. And now we are at the end of the Spring Integration: Getting Started course. Even though this is just a getting started course in the Spring Integration Learning Path, you've learned a lot. We started with the basic concepts of asynchronous messaging. You've learned about Enterprise Integration Patterns, a set of design patterns specifically about integrating software systems using messaging. The Enterprise Integration Patterns were originally described in the book by Gregor Hohpe and Bobby Woolf. Throughout the course, we've encountered many different Enterprise Integration Patterns, from messages and message channels to channel adapters, polling consumers, and event‑driven consumers, routers, transformers, service activators, and more. You have, of course, also learned a lot about Spring Integration and how it makes the Enterprise Integration Patterns available for you to use in your Spring‑based applications. We've built a nice demo application that you can experiment with to learn exactly how it all works. We started the demo with a few simple point‑to‑point channels and a service activator and then extended it with channel adapters to work with RabbitMQ. You've learned about publish‑subscribe messaging, which we used to make the application send a confirmation email and notify the billing system when a registration was made for the Globomantics Tech Conference. Finally, you've learned how to handle errors in different ways. You now have a solid understanding of Spring Integration and Enterprise Integration Patterns, and you're ready to start using it in your own applications. Of course, there's a lot more to learn about Spring Integration. There are many more Enterprise Integration Patterns that we haven't discussed in this course, and Spring Integration has many more features that we couldn't cover here. You're welcome to continue your journey to learn Spring Integration with the next courses in the Spring Integration learning path that will be available soon on Pluralsight or will already be available to you, depending on when you're watching this. I hope you found this course interesting and useful, and I wish you success with using Spring Integration in your own work.